// Generated by CoffeeScript 2.4.1
(function() {
  var _, extractRoutes, fg, handleRoute, path;

  fg = require('fast-glob');

  path = require('path');

  _ = require('lodash');

  extractRoutes = function({dir}) {
    var baseTokens, extras, file, fileName, files, index, method, name, routes, token, tokens;
    files = fg.sync([path.join(dir, '**/*.(js|ts|coffee)')]);
    return routes = (function() {
      var i, j, len, len1, results;
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        name = path.relative(dir, file);
        name = name.substring(0, name.lastIndexOf('.'));
        tokens = name.split(path.sep);
        extras = [];
        fileName = _.last(tokens);
        // excess .{---} to the left of .{method}.{ext} will be placed into an array
        method = fileName.indexOf('.') > -1 ? (baseTokens = fileName.split('.'), tokens[tokens.length - 1] = baseTokens[0], baseTokens.length > 2 ? extras = baseTokens.slice(1, baseTokens.length - 1) : void 0, _.last(baseTokens)) : 'get';
        // remove underscore only base names
        if (tokens[tokens.length - 1] === '_') {
          tokens.splice(tokens.length - 1, 1);
        }
// replace first-only underscores with path param :
        for (index = j = 0, len1 = tokens.length; j < len1; index = ++j) {
          token = tokens[index];
          if (token.indexOf('_') === 0) {
            tokens[index] = token.replace('_', ':');
          }
        }
        // add root base name if inclusive
        if (opts.inclusive) {
          tokens.unshift(path.basename(cwd));
        }
        results.push({
          // return
          path: `/${tokens.join('/')}`,
          module: require(path.join(process.cwd(), file)),
          file,
          method,
          extras
        });
      }
      return results;
    })();
  };

  handleRoute = function(fastify, route, required, custom) {
    var obj;
    // Function Mode
    if (_.isFunction(required)) {
      if (!custom) {
        return fastify.route({
          url: route.path,
          method: (route.method || 'GET').toUpperCase(),
          handler: (function(required) {
            return function(req, res) {
              return required.call(this, req, res);
            };
          })(required)
        });
      } else {
        return fastify.route(required(route));
      }
    // Object mode
    } else if (_.isObject(required)) {
      obj = _.merge({
        url: route.path,
        method: (route.method || 'GET').toUpperCase(),
        config: {
          route: route
        }
      }, required);
      if (obj.handler == null) {
        return;
      }
      return fastify.route(obj);
    } else {
      throw new Error('Unsupported module type.');
    }
  };

  module.exports = function(fastify, opts, next) {
    var custom, i, item, j, len, len1, required, route, routes;
    routes = extractRoutes(opts);
// Start registering routes to fastify
    for (i = 0, len = routes.length; i < len; i++) {
      route = routes[i];
      required = route.module;
      console.log(`Adding route -- ${route.method.toUpperCase()} ${route.path}`);
      // Static mode
      if (_.some(route.extras, function(x) {
        return x === 'static';
      })) {
        fastify[route.method](routePath, async function(req, res) {
          return (await required);
        });
        continue;
      }
      custom = _.some(route.extras, function(x) {
        return x === 'custom';
      });
      // Array mode
      if (_.isArray(required)) {
        // Shorthand route call
        if (_.isString(required[0])) {
          fastify[route.method](...required);
        } else {
// Custom Route per Element
          for (j = 0, len1 = required.length; j < len1; j++) {
            item = required[j];
            handleRoute(fastify, route, item, custom);
          }
        }
      } else {
        // Standard mode
        handleRoute(fastify, route, required, custom);
      }
    }
    return next();
  };

}).call(this);
